set_standard_analog_input_domain(0, 1)
set_standard_analog_input_domain(1, 1)
set_tool_analog_input_domain(0, 1)
set_tool_analog_input_domain(1, 1)
set_analog_outputdomain(0, 0)
set_analog_outputdomain(1, 0)
set_tool_voltage(0)
set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
set_payload(0.0)
set_gravity([0.0, 0.0, 9.82])

thread joint_sending_thread():
    open=socket_open("192.168.0.192",22, "socket_2")
  
    while (open ==  False  ):
        open=socket_open("192.168.0.192",22, "socket_2")
    end
  
    while (True):
      socket_send_string(get_actual_joint_positions(), "socket_2")
      sleep(0.8)
    end
  
end
thrd = run joint_sending_thread()

open=socket_open("192.168.0.192",21, "socket_1")

while (open ==  False  ):
    open=socket_open("192.168.0.192",21, "socket_1")
end

targetPos=p[0,0,0,0,0,0]

counter=0
## TODO: create a second thread that connect to port 22 and send joint info in that thread, in main thread: port 21, send pos info, then receive pos, then calculate inverse kin and send back the plan


while (True):
    socket_send_string(get_actual_tcp_pose(), "socket_1")

    receiveFromServ=socket_read_ascii_float(6)

    while (receiveFromServ[0] !=6):

        sleep(0.3)
    
        receiveFromServ=socket_read_ascii_float(6)
    end

    while (counter <6):

        targetPos[counter]=receiveFromServ[counter+1]

        counter=counter+1
    end
    counter=0

    current_joint_positions = get_actual_joint_positions()

    target_joint_pose = get_inverse_kin(targetPos, current_joint_positions) #  pass in a qnear opitonal parameter (second param) which specify the solution should be near which joint position
    #movej(target_joint_pose, 1.5, 0.5, 0, 0)
    socket_send_string(target_joint_pose, "socket_1")

    #servoj(target_joint_pose, 0, 0, 0.1, 0.5, 300)
    

    #movej(targetPos, a=1.3962634015954636, v=1.0471975511965976)
    #sleep(0.2)


    #socket_send_string(get_actual_joint_positions())


    #socket_send_string(get_actual_tcp_pose())
    
end



